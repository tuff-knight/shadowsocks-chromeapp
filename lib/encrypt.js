// Generated by CoffeeScript 2.7.0
// Copyright (c) 2015 clowwindy

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// (str, str)
var Encryptor;

Encryptor = function(key1, method1, one_time_auth1 = false) {
  this.key = key1;
  this.method = method1;
  this.one_time_auth = one_time_auth1;
  this.iv_sent = false;
  this.decipher = null;
  this.cipher_counter = 0;
  this._method_info = Encryptor.get_method_info(this.method);
  this.cipher_iv = forge.random.getBytesSync(this._method_info[1]);
  if (this._method_info) {
    this.cipher = this.get_cipher(this.key, this.method, 1, this.cipher_iv);
  } else {
    console._error(`method ${method} is not supported.`);
  }
};

Encryptor.method_supported = {
  'rc4-md5': [16, 16, Crypto.RC4_MD5],
  'aes-128-cfb': [16, 16, Crypto.Forge],
  'aes-192-cfb': [24, 16, Crypto.Forge],
  'aes-256-cfb': [32, 16, Crypto.Forge],
  'aes-128-ofb': [16, 16, Crypto.Forge],
  'aes-192-ofb': [24, 16, Crypto.Forge],
  'aes-256-ofb': [32, 16, Crypto.Forge],
  'aes-128-ctr': [16, 16, Crypto.Forge],
  'aes-192-ctr': [24, 16, Crypto.Forge],
  'aes-256-ctr': [32, 16, Crypto.Forge]
};

// (str, int, int) -> [binstr, binstr]
Encryptor._bytes_to_key_cache = {};

Encryptor.EVP_BytesToKey = function(password, key_len, iv_len) {
  var cached_key, count, d, data, iv, key, m, md5, ms;
  cached_key = `${password}-${key_len}-${iv_len}`;
  if (cached_key in Encryptor._bytes_to_key_cache) {
    return Encryptor._bytes_to_key_cache[cached_key];
  }
  m = [];
  count = 0;
  while (count < key_len + iv_len) {
    md5 = forge.md.md5.create();
    data = (m[m.length - 1] || '') + password;
    md5.update(data);
    d = md5.digest().bytes();
    m.push(d);
    count += d.length;
  }
  ms = m.join('');
  key = ms.slice(0, key_len);
  iv = ms.slice(key_len, key_len + iv_len);
  Encryptor._bytes_to_key_cache[cached_key] = [key, iv];
  return [key, iv];
};

// (str) -> [int, int, cipherclass]
Encryptor.get_method_info = function(method) {
  return Encryptor.method_supported[method.toLowerCase()];
};

// () -> int
Encryptor.prototype.iv_len = function() {
  return this.cipher_iv.length;
};

// (str, str, 0/1, binstr) -> cipher
Encryptor.prototype.get_cipher = function(password, method, op, iv) {
  var impl, iv_len, key_len;
  [key_len, iv_len, impl] = this._method_info;
  [this.cipher_key] = Encryptor.EVP_BytesToKey(password, key_len, iv_len);
  return new impl(method, this.cipher_key, iv, op);
};

// (Uint8Array) -> Uint8Array
Encryptor.prototype.encrypt = function(buf) {
  var auth_data, buf_len, cipher_iv_array, combined, encrypted_array, hmac;
  if (buf.length === 0) {
    return buf;
  }
  if (this.iv_sent && !this.one_time_auth) {
    return this.cipher.update(buf);
  }
  if (this.iv_sent) {
    buf_len = buf.length;
    hmac = forge.hmac.create();
    hmac.start('sha1', this.cipher_iv + forge.util.int32ToBytes(this.cipher_counter++));
    hmac.update(Common.uint82Str(buf));
    auth_data = hmac.digest().getBytes().slice(0, 10);
    combined = new Uint8Array(2 + 10 + buf_len);
    combined[0] = (buf_len & 0xff00) >> 8;
    combined[1] = buf_len & 0x00ff;
    combined.set(Common.str2Uint8(auth_data), 2);
    combined.set(buf, 12);
    return this.cipher.update(combined);
  } else {
    this.iv_sent = true;
    if (this.one_time_auth) {
      buf[0] |= 0x10;
      buf = Common.uint82Str(buf);
      hmac = forge.hmac.create();
      hmac.start('sha1', this.cipher_iv + this.cipher_key);
      hmac.update(buf);
      buf += hmac.digest().getBytes().slice(0, 10);
      buf = Common.str2Uint8(buf);
    }
    encrypted_array = this.cipher.update(buf);
    cipher_iv_array = Common.str2Uint8(this.cipher_iv);
    combined = new Uint8Array(cipher_iv_array.length + encrypted_array.length);
    combined.set(cipher_iv_array, 0);
    combined.set(encrypted_array, cipher_iv_array.length);
    return combined;
  }
};

// (Uint8Array|binstr) -> Uint8Array
Encryptor.prototype.decrypt = function(buf) {
  var decipher_iv_len;
  if (Object.prototype.toString.call(buf) === "[object String]") {
    buf = Common.str2Uint8(buf);
  }
  if (buf.length === 0) {
    return buf;
  }
  if (this.decipher == null) {
    decipher_iv_len = this._method_info[1];
    this.decipher_iv = Common.uint82Str(buf.subarray(0, decipher_iv_len));
    this.decipher = this.get_cipher(this.key, this.method, 0, this.decipher_iv);
    buf = new Uint8Array(buf.subarray(decipher_iv_len));
    if (buf.length === 0) {
      return buf;
    }
  }
  return this.decipher.update(buf);
};

// (String, String, 0|1, Uint8Array, Boolean) -> Uint8Array
Encryptor.encrypt_all = function(password, method, op, data, one_time_auth) {
  var cipher, combined, encrypted_array, hmac, impl, iv, iv_len, key, key_len;
  [key_len, iv_len, impl] = Encryptor.get_method_info(method);
  [key] = Encryptor.EVP_BytesToKey(password, key_len, iv_len);
  if (op === 1) { // Encrypt
    iv = forge.random.getBytesSync(iv_len);
    if (one_time_auth) {
      data[0] |= 0x10;
      data = Common.uint82Str(data);
      hmac = forge.hmac.create();
      hmac.start('sha1', iv + key);
      hmac.update(data);
      data = Common.str2Uint8(data + hmac.digest().getBytes().slice(0, 10));
    }
  } else {
    iv = Common.uint82Str(data.subarray(0, iv_len));
    data = new Uint8Array(data.subarray(iv_len));
  }
  cipher = new impl(method, key, iv, op);
  encrypted_array = cipher.update(data);
  if (op === 0) {
    return encrypted_array;
  }
  combined = new Uint8Array(iv_len + encrypted_array.length);
  combined.set(Common.str2Uint8(iv), 0);
  combined.set(encrypted_array, iv_len);
  return combined;
};
