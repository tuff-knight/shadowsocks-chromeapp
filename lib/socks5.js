// Generated by CoffeeScript 2.7.0
// Copyright (c) 2015 Sunny

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
var SOCKS5;

SOCKS5 = function(config = {}) {
  this.tcp_socket_info = {};
  this.udp_socket_info = {};
  this.socket_server_id = null;
  ({server: this.server, server_port: this.server_port, password: this.password, method: this.method, local_port: this.local_port, timeout: this.timeout, one_time_auth: this.one_time_auth} = config);
};

SOCKS5.prototype.handle_accept = function(info) {
  var clientSocketId, socketId;
  ({socketId, clientSocketId} = info);
  if (socketId !== this.socket_server_id) {
    return;
  }
  this.tcp_socket_info[clientSocketId] = {
    type: "local",
    status: "auth",
    cipher: new Encryptor(this.password, this.method, this.one_time_auth),
    socket_id: clientSocketId,
    cipher_action: "encrypt",
    peer_socket_id: null,
    last_connection: Date.now()
  };
  chrome.sockets.tcp.setPaused(clientSocketId, false);
  return console._debug(`Accepting to new socket: ${clientSocketId}`);
};

SOCKS5.prototype.handle_recv = function(info) {
  var array, data, socketId;
  ({socketId, data} = info);
  if (!(socketId in this.tcp_socket_info)) {
    console._info(`Unknown or closed TCP socket: ${socketId}`);
    return this.close_socket(socketId, false, "tcp");
  }
  console._verbose(`TCP socket ${socketId}: data received.`);
  array = new Uint8Array(data);
  switch (this.tcp_socket_info[socketId].status) {
    case "cmd":
      return this.cmd(socketId, array);
    case "auth":
      return this.auth(socketId, array);
    case "tcp_relay":
      return this.tcp_relay(socketId, array);
    case "udp_relay":
      return console._info("Unexcepted TCP packet received when relaying udp:", array);
    default:
      return console._warn(`FSM: Not a valid state for ${socketId}: ${this.tcp_socket_info[socketId].status}.`);
  }
};

SOCKS5.prototype.handle_udp_recv = function(info) {
  var data, remoteAddress, remotePort, socketId;
  ({socketId, data, remoteAddress, remotePort} = info);
  if (!(socketId in this.udp_socket_info)) {
    console._info(`Unknown or closed UDP socket: ${socketId}`);
    return this.close_socket(socketId, false, "udp");
  }
  console._verbose(`UDP socket ${socketId}: data received.`);
  return this.udp_relay(socketId, new Uint8Array(data), remoteAddress, remotePort);
};

SOCKS5.prototype.handle_accepterr = function(info) {
  var resultCode, socketId;
  ({socketId, resultCode} = info);
  return console._warn(`Accepting on server socket ${socketId} occurs accept error ${resultCode}`);
};

SOCKS5.prototype.handle_recverr = function(info) {
  var resultCode, socketId;
  ({socketId, resultCode} = info);
  if (resultCode !== -100) {
    console._info(`TCP socket ${socketId} occurs receive error ${resultCode}`);
  }
  return this.close_socket(socketId);
};

SOCKS5.prototype.handle_udp_recverr = function(info) {
  var resultCode, socketId;
  ({socketId, resultCode} = info);
  console._info(`UDP socket ${socketId} occurs receive error ${resultCode}`);
  if (socketId in this.udp_socket_info) {
    return this.close_socket(this.udp_socket_info[socketId].host_tcp_id);
  } else {
    return this.close_socket(socketId, false, "udp");
  }
};

SOCKS5.prototype.config = function(config) {
  return ({server: this.server, server_port: this.server_port, password: this.password, method: this.method, local_port: this.local_port, timeout: this.timeout, one_time_auth: this.one_time_auth} = config);
};

SOCKS5.prototype.listen = function(callback) {
  return chrome.sockets.tcpServer.create({}, (createInfo) => {
    this.socket_server_id = createInfo.socketId;
    return chrome.sockets.tcpServer.listen(this.socket_server_id, '0.0.0.0', this.local_port | 0, (result) => {
      if (result < 0 || chrome.runtime.lastError) {
        console.error(`Listen on port ${this.local_port} failed:`, chrome.runtime.lastError.message);
        chrome.sockets.tcpServer.close(this.socket_server_id);
        this.socket_server_id = null;
        callback.call(null, `Listen on port ${this.local_port} failed:` + chrome.runtime.lastError.message);
        return;
      }
      console.info(`Listening on port ${this.local_port}...`);
      chrome.sockets.tcpServer.onAccept.addListener(this.accept_handler = (info) => {
        return this.handle_accept(info);
      });
      chrome.sockets.tcpServer.onAcceptError.addListener(this.accepterr_handler = (info) => {
        return this.handle_accepterr(info);
      });
      chrome.sockets.tcp.onReceive.addListener(this.recv_handler = (info) => {
        return this.handle_recv(info);
      });
      chrome.sockets.tcp.onReceiveError.addListener(this.recverr_handler = (info) => {
        return this.handle_recverr(info);
      });
      chrome.sockets.udp.onReceive.addListener(this.udp_recv_handler = (info) => {
        return this.handle_udp_recv(info);
      });
      chrome.sockets.udp.onReceiveError.addListener(this.udp_recverr_handler = (info) => {
        return this.handle_udp_recverr(info);
      });
      this.sweep_task_id = setInterval(() => {
        return this.sweep_socket();
      }, this.timeout * 1000);
      return callback.call(null, `Listening on port ${this.local_port}...`);
    });
  });
};

SOCKS5.prototype.terminate = function(callback) {
  console.info("Terminating server...");
  chrome.sockets.tcpServer.onAccept.removeListener(this.accept_handler);
  chrome.sockets.tcpServer.onAcceptError.removeListener(this.accepterr_handler);
  chrome.sockets.tcp.onReceive.removeListener(this.recv_handler);
  chrome.sockets.tcp.onReceiveError.removeListener(this.recverr_handler);
  chrome.sockets.udp.onReceive.removeListener(this.udp_recv_handler);
  chrome.sockets.udp.onReceiveError.removeListener(this.udp_recverr_handler);
  if (!this.socket_server_id) {
    callback.call(null, "Server had been terminated");
    return console.info("Server had been terminated");
  }
  return chrome.sockets.tcpServer.close(this.socket_server_id, () => {
    var socket_id;
    this.socket_server_id = null;
    clearInterval(this.sweep_task_id);
    for (socket_id in this.tcp_socket_info) {
      this.close_socket(socket_id, false, "tcp");
    }
    for (socket_id in this.udp_socket_info) {
      this.close_socket(socket_id, false, "udp");
    }
    callback.call(null, "Server has been terminated");
    return console.info("Server has been terminated");
  });
};

SOCKS5.prototype.auth = function(socket_id, data) {
  console._debug("Start processing auth procedure");
  if (data[0] !== 0x05) { // VER
    this.close_socket(socket_id);
    console._warn("Not a valid SOCKS5 auth packet, closed.");
    return;
  }
  if (Common.typedIndexOf(data, 0x00, 2) === -1) { // Bypass VER and NMETHODS
    console._warn("Client doesn't support no authentication.");
    chrome.sockets.tcp.send(socket_id, new Uint8Array([0x05, 0xFF]).buffer, () => {
      return this.close_socket(socket_id);
    });
    return;
  }
  return chrome.sockets.tcp.send(socket_id, new Uint8Array([0x05, 0x00]).buffer, (sendInfo) => {
    if (!sendInfo || sendInfo.resultCode < 0 || chrome.runtime.lastError) {
      console._error("Failed to send choice no authentication method to client:", chrome.runtime.lastError.message);
      this.close_socket(socket_id, false, "tcp");
      return;
    }
    this.tcp_socket_info[socket_id].status = "cmd";
    this.tcp_socket_info[socket_id].last_connection = Date.now();
    return console._log("SOCKS5 auth passed");
  });
};

SOCKS5.prototype.cmd = function(socket_id, data) {
  var header, reply;
  if (data[0] !== 0x05 || data[2] !== 0x00) { // VER and RSV
    console._warn("Not a valid SOCKS5 cmd packet.");
    this.close_socket(socket_id);
    return;
  }
  header = Common.parseHeader(data);
  switch (header.cmd) {
    case 0x01:
      this.cmd_connect(socket_id, header, data);
      break;
    case 0x02:
      this.cmd_bind(socket_id, header, data);
      break;
    case 0x03:
      this.cmd_udpassoc(socket_id, header, data);
      break;
    default:
      reply = Common.packHeader(0x07, 0x01, '0.0.0.0', 0);
      chrome.sockets.tcp.send(socket_id, reply.buffer, () => {
        return this.close_socket(socket_id);
      });
      console._warn("Not a valid CMD field.");
  }
  return this.tcp_socket_info[socket_id].last_connection = Date.now();
};

SOCKS5.prototype.cmd_connect = function(socket_id, header, origin_data) {
  // TODO: try/catch surround?
  console._debug("Start processing connect command");
  if (!(socket_id in this.tcp_socket_info)) {
    return;
  }
  return chrome.sockets.tcp.create({
    name: 'remote_socket'
  }, (createInfo) => {
    this.tcp_socket_info[socket_id].peer_socket_id = createInfo.socketId;
    console._verbose(`TCP socket to remote server created on ${createInfo.socketId}`);
    return chrome.sockets.tcp.connect(createInfo.socketId, this.server, this.server_port | 0, (result) => {
      var data, error_reply;
      error_reply = Common.packHeader(0x01, 0x01, '0.0.0.0', 0);
      if (result < 0 || chrome.runtime.lastError) {
        console._error("Failed to connect to shadowsocks server:", chrome.runtime.lastError.message);
        chrome.sockets.tcp.send(socket_id, error_reply.buffer, () => {
          this.close_socket(socket_id);
          return this.close_socket(createInfo.socketId);
        });
        return;
      }
      console._verbose(`TCP socket ${createInfo.socketId} to remote server connection established`);
      this.tcp_socket_info[createInfo.socketId] = {
        type: "remote",
        status: "tcp_relay",
        cipher: this.tcp_socket_info[socket_id].cipher,
        socket_id: createInfo.socketId,
        peer_socket_id: socket_id,
        cipher_action: "decrypt",
        last_connection: Date.now()
      };
      data = this.tcp_socket_info[socket_id].cipher.encrypt(new Uint8Array(origin_data.subarray(3)));
      return chrome.sockets.tcp.send(createInfo.socketId, data.buffer, (sendInfo) => {
        if (!sendInfo || sendInfo.resultCode < 0 || chrome.runtime.lastError) {
          console._error("Failed to send encrypted request to shadowsocks server:", chrome.runtime.lastError.message);
          chrome.sockets.tcp.send(socket_id, error_reply.buffer, () => {
            return this.close_socket(socket_id);
          });
          return;
        }
        console._verbose("TCP relay request had been sent to remote server");
        data = Common.packHeader(0x00, 0x01, '0.0.0.0', 0);
        return chrome.sockets.tcp.send(socket_id, data.buffer, (sendInfo) => {
          if (!sendInfo || sendInfo.resultCode < 0 || chrome.runtime.lastError) {
            console._error("Failed to send connect success reply to client:", chrome.runtime.lastError.message);
            this.close_socket(socket_id);
            return;
          }
          this.tcp_socket_info[socket_id].status = "tcp_relay";
          return console._log("SOCKS5 connect okay");
        });
      });
    });
  });
};

SOCKS5.prototype.cmd_bind = function(socket_id, header, origin_data) {
  var data;
  console._warn("CMD BIND is not implemented in shadowsocks.");
  data = Common.packHeader(0x07, 0x01, '0.0.0.0', 0);
  return chrome.sockets.tcp.send(socket_id, data.buffer, () => {
    return this.close_socket(socket_id);
  });
};

SOCKS5.prototype.cmd_udpassoc = function(socket_id, header, origin_data) {
  console._debug(`Udp associated request on socket ${socket_id}`);
  if (!(socket_id in this.tcp_socket_info)) {
    return;
  }
  return chrome.sockets.udp.create({
    name: "local_socket"
  }, (socketInfo) => {
    var socketId;
    socketId = socketInfo.socketId; // local udp socket id
    this.udp_socket_info[socketId] = {
      type: "local",
      socket_id: socketId,
      host_tcp_id: socket_id,
      peer_socket_id: null,
      last_connection: Date.now(),
      remote_address: null,
      remote_port: null
    };
    return chrome.sockets.udp.bind(socketId, '127.0.0.1', 0, (result) => {
      if (result < 0 || chrome.runtime.lastError) {
        console._error("Failed to bind local UDP socket to free port", chrome.runtime.lastError.message);
        this.close_socket(socketId, false, "udp");
        this.close_socket(socket_id, false, "tcp");
        return;
      }
      console._verbose("UDP local-side socket created and bound");
      return chrome.sockets.udp.create({
        name: "remote_socket"
      }, (socketInfo) => {
        this.udp_socket_info[socketId].peer_socket_id = socketInfo.socketId;
        this.udp_socket_info[socketInfo.socketId] = {
          type: "remote",
          socket_id: socketInfo.socketId,
          host_tcp_id: socket_id,
          peer_socket_id: socketId,
          last_connection: Date.now()
        };
        return chrome.sockets.udp.bind(socketInfo.socketId, '0.0.0.0', 0, (result) => {
          if (result < 0 || chrome.runtime.lastError) {
            console._error("Failed to bind remote UDP socket to free port", chrome.runtime.lastError.message);
            this.close_socket(socket_id, false, "tcp");
            this.close_socket(socketInfo.socketId, true, "udp");
            return;
          }
          console._verbose("UDP remote-side socket created and bound");
          return chrome.sockets.udp.getInfo(socketId, (socketInfo) => {
            var data, localAddress, localPort;
            ({localAddress, localPort} = socketInfo); // local udp socket addr and port
            console._verbose(`UDP local-side socket bound on ${localAddress}:${localPort}`);
            data = Common.packHeader(0x00, null, localAddress, localPort);
            return chrome.sockets.tcp.send(socket_id, data.buffer, (sendInfo) => {
              if (!sendInfo || sendInfo.resultCode < 0 || chrome.runtime.lastError) {
                console._error("Failed to send UDP relay init success message", chrome.runtime.lastError.message);
                this.close_socket(socketId, true, "udp");
                this.close_socket(socket_id, false, "tcp");
                return;
              }
              this.tcp_socket_info[socket_id].status = "udp_relay";
              this.tcp_socket_info[socket_id].peer_socket_id = socketId;
              return console._log("TCP reply for success init UDP relay sent");
            });
          });
        });
      });
    });
  });
};

SOCKS5.prototype.tcp_relay = function(socket_id, data_array) {
  var data, now, peer_socket_id, socket_info;
  // TODO: try/catch surround?
  if (!(socket_id in this.tcp_socket_info)) {
    return;
  }
  now = Date.now();
  socket_info = this.tcp_socket_info[socket_id];
  socket_info.last_connection = now;
  peer_socket_id = socket_info.peer_socket_id;
  if (!(peer_socket_id in this.tcp_socket_info)) {
    return;
  }
  this.tcp_socket_info[peer_socket_id].last_connection = now;
  // console._verbose "Relaying TCP data from #{socket_id} to #{peer_socket_id}"
  data = socket_info.cipher[socket_info.cipher_action](data_array);
  return chrome.sockets.tcp.send(peer_socket_id, data.buffer, (sendInfo) => {
    if (!sendInfo || sendInfo.resultCode < 0 || chrome.runtime.lastError && socket_id in this.tcp_socket_info) {
      console._info(`Failed to relay TCP data from ${socket_info.type} ${socket_id} to peer ${peer_socket_id}:`, chrome.runtime.lastError);
      return this.close_socket(socket_id);
    }
  });
};

SOCKS5.prototype.udp_relay = function(socket_id, data_array, remote_address, remote_port) {
  var addr, data, decrypted, now, peer_socket_id, port, socket_info;
  // TODO: try/catch surround?
  now = Date.now();
  socket_info = this.udp_socket_info[socket_id];
  socket_info.last_connection = now;
  peer_socket_id = socket_info.peer_socket_id;
  this.udp_socket_info[peer_socket_id].last_connection = now;
  this.tcp_socket_info[socket_info.host_tcp_id].last_connection = now;
  // console._verbose "Relaying UDP data from #{socket_id} to #{peer_socket_id}"
  if (socket_info.type === "local") {
    if (data_array[2] !== 0x00) {
      return console._info("Drop unsupported fragmentation");
    }
    socket_info.remote_address = remote_address;
    socket_info.remote_port = remote_port;
    data = Encryptor.encrypt_all(this.password, this.method, 1, new Uint8Array(data_array.subarray(3)), this.one_time_auth);
    addr = this.server;
    port = this.server_port | 0;
  } else {
    decrypted = Encryptor.encrypt_all(this.password, this.method, 0, data_array, this.one_time_auth);
    data = new Uint8Array(decrypted.length + 3);
    data.set(decrypted, 3); // First 3 elements default to 0 when created
    addr = this.udp_socket_info[peer_socket_id].remote_address;
    port = this.udp_socket_info[peer_socket_id].remote_port;
  }
  return chrome.sockets.udp.send(peer_socket_id, data.buffer, addr, port, (sendInfo) => {
    if (sendInfo.resultCode < 0 || chrome.runtime.lastError) {
      console._info(`Failed to relay UDP data from ${socket_info.type} ${socket_id} to peer ${peer_socket_id}:`, chrome.runtime.lastError);
      return this.close_socket(socket_info.host_tcp_id, true, "tcp");
    }
  });
};

SOCKS5.prototype.close_socket = function(socket_id, close_peer = true, protocol = "tcp") {
  var peer_socket_id;
  console._debug(`Closing ${protocol} socket ${socket_id}`);
  socket_id |= 0; // convert possible string to number
  if (socket_id in this[`${protocol}_socket_info`]) {
    peer_socket_id = this[`${protocol}_socket_info`][socket_id].peer_socket_id;
    if (close_peer && this[`${protocol}_socket_info`][socket_id].status === "udp_relay") {
      this.close_socket(peer_socket_id, true, "udp");
      close_peer = false;
    }
    delete this[`${protocol}_socket_info`][socket_id]['cipher'];
    delete this[`${protocol}_socket_info`][socket_id];
  }
  return chrome.sockets[protocol].close(socket_id, () => {
    if (chrome.runtime.lastError && chrome.runtime.lastError.message !== "Socket not found") {
      console._info(`Error on close ${protocol} socket ${socket_id}:`, chrome.runtime.lastError.message);
    }
    console._log(`${protocol} socket ${socket_id} closed`);
    if (close_peer && peer_socket_id in this[`${protocol}_socket_info`]) {
      return this.close_socket(peer_socket_id, false, protocol);
    }
  });
};

SOCKS5.prototype.sweep_socket = function() {
  var ref, ref1, socket, socket_id;
  console._debug("Sweeping timeouted socket...");
  ref = this.tcp_socket_info;
  for (socket_id in ref) {
    socket = ref[socket_id];
    if (Date.now() - socket.last_connection >= this.timeout * 1000) {
      chrome.sockets.tcp.getInfo(socket_id | 0, (socketInfo) => {
        if (!socketInfo.connected) {
          this.close_socket(socket_id);
        }
        return console._log(`TCP socket ${socket_id} has been swept`);
      });
    }
  }
  ref1 = this.udp_socket_info;
  for (socket_id in ref1) {
    socket = ref1[socket_id];
    if (Date.now() - socket.last_connection >= this.timeout * 1000) {
      this.close_socket(socket_id, true, "udp");
      console._log(`UDP socket ${socket_id} has been swept`);
    }
  }
};
