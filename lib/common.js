// Generated by CoffeeScript 2.7.0
// Copyright (c) 2015 Sunny

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
var Common;

Common = {};

// (String) -> Uint8Array
Common.str2Uint8 = function(str) {
  var arr, i, j, ref;
  arr = new Uint8Array(str.length);
  for (i = j = 0, ref = str.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
    arr[i] = str.charCodeAt(i);
  }
  return arr;
};

// (Uint8Array) -> String
Common.uint82Str = function(uint8) {
  return String.fromCharCode(...uint8);
};

// (TypedArray|Array, Number, int) -> int
Common.typedIndexOf = function(typedArray, searchElement, fromIndex = 0) {
  var element, index, j, len1;
  for (index = j = 0, len1 = typedArray.length; j < len1; index = ++j) {
    element = typedArray[index];
    if (element === searchElement && index >= fromIndex) {
      return index;
    }
  }
  return -1;
};

// (TypedArray|Array, TypedArray|Array, int, int, int, int) -> int
Common.typedArrayCpy = function(dst, src, dstStart = 0, srcStart = 0, dstEnd = dst.length, srcEnd = src.length) {
  var i, j, len, ref, ref1;
  len = Math.min(srcEnd - srcStart, dstEnd - dstStart);
  for (i = j = ref = dstStart, ref1 = dstStart + len; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
    dst[i] = src[srcStart + i - dstStart];
  }
  return len;
};

// (int, int, ...) -> String
Common.bytes2FixedHexString = function(...bytes) {
  var byte;
  return ((function() {
    var j, len1, results;
    results = [];
    for (j = 0, len1 = bytes.length; j < len1; j++) {
      byte = bytes[j];
      results.push((byte < 16 ? "0" : "") + byte.toString(16));
    }
    return results;
  })()).join('');
};

// (0x01|0x04, TypedArray|Array<int>) -> String
Common.inet_ntop = function(family, array) {
  var i;
  if (family === 0x01 && array.length === 4) { // IPv4
    return ((function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = array.length; j < len1; j++) {
        i = array[j];
        results.push(i);
      }
      return results;
    })()).join('.');
  } else if (family === 0x04 && array.length === 16) { // IPv6
    return ((function() {
      var j, results;
      results = [];
      for (i = j = 0; j < 16; i = j += 2) {
        results.push(Common.bytes2FixedHexString(array[i], array[i + 1]));
      }
      return results;
    })()).join(':');
  } else {
    return console.error("Not a valid family.");
  }
};

// (0x01|0x04, String) -> Array<int>
Common.inet_pton = function(family, str) {
  var byte, bytes, grp, i, j, k, len1, newaddr, ref, twoBytes, v4arr, v6like;
  if (family === 0x01) { // IPv4
    return (function() {
      var j, len1, ref, results;
      ref = str.split('.');
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        byte = ref[j];
        results.push(parseInt(byte));
      }
      return results;
    })();
  } else if (family === 0x04) { // IPv6
    if (str.indexOf('.') >= 0) {
      v4arr = Common.inet_pton(0x01, str.slice(str.lastIndexOf(':') + 1));
      v6like = ((function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 4; i = j += 2) {
          results.push(Common.bytes2FixedHexString(v4arr[i], v4arr[i + 1]));
        }
        return results;
      })()).join(':');
      newaddr = str.slice(0, str.lastIndexOf(':') + 1) + v6like;
      return Common.inet_pton(family, newaddr);
    }
    bytes = [];
    grp = str.split(':');
    if (grp[0] === "") {
      grp.shift();
    }
    if (grp[grp.length - 1] === "") {
      grp.pop();
    }
    for (j = 0, len1 = grp.length; j < len1; j++) {
      twoBytes = grp[j];
      if (twoBytes === "") {
        for (i = k = 0, ref = 16 - (grp.length - 1) * 2; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          bytes.push(0);
        }
      } else {
        bytes.push(parseInt(twoBytes.slice(0, 2), 16));
        bytes.push(parseInt(twoBytes.slice(2, 4), 16));
      }
    }
    return bytes;
  } else {
    return console.error("Not a valid family.");
  }
};

Common.regExpIPv4 = /((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])/;

Common.regExpIPv6 = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/; // Regexps credits to David M. Syzdek @ stackoverflow
// 1:2:3:4:5:6:7:8
// 1::                              1:2:3:4:5:6:7::
// 1::8             1:2:3:4:5:6::8  1:2:3:4:5:6::8
// 1::7:8           1:2:3:4:5::7:8  1:2:3:4:5::8
// 1::6:7:8         1:2:3:4::6:7:8  1:2:3:4::8
// 1::5:6:7:8       1:2:3::5:6:7:8  1:2:3::8
// 1::4:5:6:7:8     1:2::4:5:6:7:8  1:2::8
// 1::3:4:5:6:7:8   1::3:4:5:6:7:8  1::8  
// ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8 ::8       ::     
// fe80::7:8%eth0   fe80::7:8%1     (link-local IPv6 addresses with zone index)
// ::255.255.255.255   ::ffff:255.255.255.255  ::ffff:0:255.255.255.255  (IPv4-mapped IPv6 addresses and IPv4-translated addresses)
// 2001:db8:3:4::192.0.2.33  64:ff9b::192.0.2.33 (IPv4-Embedded IPv6 Address)

Common.guessFamily = function(str) { // (String) -> 0x01|0x03|0x04
  if (Common.regExpIPv4.test(str)) {
    return 0x01;
  } else if (Common.regExpIPv6.test(str)) {
    return 0x04;
  } else {
    return 0x03;
  }
};

// (Uint8Array) -> Object
Common.parseHeader = function(data) {
  var dst, len, port, prt;
  switch (data[3]) {
    case 0x01: // IPv4
      dst = Common.inet_ntop(data[3], data.subarray(4, -2));
      break;
    case 0x03: // doamin name
      if (data.length > 2 + 6) { // 6 contains VER, CMD, RSV, ATYP, PORT(2)
        len = data[4];
        dst = Common.uint82Str(data.subarray(5, len + 5));
      } else {
        console.warn("Header is too short.");
        return null;
      }
      break;
    case 0x04: // IPv6
      dst = Common.inet_ntop(data[3], data.subarray(4, -2));
      break;
    default:
      console.error("Not a valid ATYP.");
      return null;
  }
  prt = data.subarray(-2);
  port = prt[0] << 8 | prt[1];
  return {
    ver: data[0],
    cmd: data[1],
    rsv: data[2],
    atyp: data[3],
    dst: dst,
    port: port
  };
};

// (int, 0x01|0x03|0x04|0x80|null, String, String|int) -> Uint8Array
// set atyp to null or 0x80 means guess the type of address
Common.packHeader = function(rep, atyp = 0x80, addr, port) {
  var arr, bindAddr, index, len;
  switch (atyp) {
    case 0x01:
      len = 10; // 1 (VER) + 1 (REP) + 1 (RSV) + 1 (ATYP) + 4 (BND.ADDR) + 2 (BND.PORT)
      break;
    case 0x03:
      len = 7 + addr.length; // VER + REP + RSV + ATYP + (1 + LEN)(BND.ADDR) + BND.PORT
      break;
    case 0x04:
      len = 22; // VER + REP + RSV + ATYP + 16 (BND.ADDR) + BND.PORT
      break;
    case 0x80:
      return Common.packHeader(rep, Common.guessFamily(addr), addr, port);
    default:
      return console.error("Not a valid ATYP.");
  }
  index = 0;
  arr = new Uint8Array(len);
  arr[index++] = 0x05; // VER = 0x05
  arr[index++] = rep;
  arr[index++] = 0x00; // RSV = 0x00
  arr[index++] = atyp;
  if (atyp === 0x03) {
    arr[index++] = addr.length;
  }
  if (atyp === 0x01 || atyp === 0x04) {
    bindAddr = Common.inet_pton(atyp, addr);
  } else {
    bindAddr = Common.str2Uint8(addr);
  }
  index += Common.typedArrayCpy(arr, bindAddr, index);
  arr[index++] = (port & 0xff00) >> 8;
  arr[index++] = port & 0xff;
  console.assert(index === len);
  return arr;
};

Common.test = function() {
  var arr1, arr2, array_equals, testHeader;
  array_equals = function(arr1, arr2) {
    var i, j, ref;
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = j = 0, ref = arr1.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  };
  // Test for uint8 <=> string
  console.assert(array_equals(Common.str2Uint8("h.w"), new Uint8Array([104, 46, 119])));
  console.assert(Common.uint82Str(new Uint8Array([104, 46, 119])) === "h.w");
  // Test for typedIndexOf
  console.assert(Common.typedIndexOf(new Uint8Array([0xa1, 0x35, 0xc0, 0x35]), 0x35, 1) === 1);
  console.assert(Common.typedIndexOf(new Uint8Array([0xa1, 0x35, 0xc0, 0x35]), 0x35, 2) === 3);
  // Test for typedArrayCpy
  arr1 = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
  arr2 = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
  console.assert(Common.typedArrayCpy(arr1, arr2, 4, 8, 6, 12) === 2);
  console.assert(array_equals(arr1, new Uint8Array([0, 1, 2, 3, 8, 9, 6, 7, 8, 9, 10, 11, 12])));
  // Test for bytes2FixedHexString
  console.assert(Common.bytes2FixedHexString(0xff, 0x00) === "ff00");
  // Test for inet_ntop
  console.assert(Common.inet_ntop(0x01, new Uint8Array([0xcb, 0xd0, 0x29, 0x91])) === "203.208.41.145");
  console.assert(Common.inet_ntop(0x04, new Uint8Array([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])) === "1234:5678:90ab:cdef:1234:5678:90ab:cdef");
  // Test for inet_pton
  console.assert(array_equals(Common.inet_pton(0x01, "203.208.41.145"), [0xcb, 0xd0, 0x29, 0x91]));
  console.assert(array_equals(Common.inet_pton(0x04, "1234:5678:90ab:cdef:1234:5678:90ab:cdef"), [0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef]));
  console.assert(array_equals(Common.inet_pton(0x04, "1234::5678:203.208.41.145"), [0x12, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x78, 0xcb, 0xd0, 0x29, 0x91]));
  console.assert(array_equals(Common.inet_pton(0x04, "1234::5678"), [0x12, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x78]));
  console.assert(array_equals(Common.inet_pton(0x04, "::1234:5678"), [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78]));
  console.assert(array_equals(Common.inet_pton(0x04, "1234:5678::"), [0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]));
  // Test for guess family
  console.assert(Common.guessFamily("192.168.1.0") === 0x01);
  console.assert(Common.guessFamily("www.google.com") === 0x03);
  console.assert(Common.guessFamily("1234::5678") === 0x04);
  console.assert(Common.guessFamily("::1234:5678") === 0x04);
  console.assert(Common.guessFamily("1234:5678::") === 0x04);
  console.assert(Common.guessFamily("1234:5678:90ab:cdef:1234:5678:90ab:cdef") === 0x04);
  // Test for parseHeader
  testHeader = Common.parseHeader(new Uint8Array([0x05, 0x01, 0x00, 0x01, 0xcb, 0xd0, 0x29, 0x91, 0x01, 0xbb]));
  console.assert(testHeader.atyp === 0x01 && testHeader.dst === "203.208.41.145" && testHeader.port === 443);
  testHeader = Common.parseHeader(new Uint8Array([0x05, 0x01, 0x00, 0x03, 0x03, 0x68, 0x2e, 0x77, 0x00, 0x50]));
  console.assert(testHeader.atyp === 0x03 && testHeader.dst === "h.w" && testHeader.port === 80);
  testHeader = Common.parseHeader(new Uint8Array([0x05, 0x01, 0x00, 0x04, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x1f, 0x90]));
  console.assert(testHeader.ver = 0x05 && (testHeader.cmd = 0x01 && testHeader.atyp === 0x04 && testHeader.dst === "1234:5678:90ab:cdef:1234:5678:90ab:cdef" && testHeader.port === 8080));
  // Test for packHeader
  testHeader = Common.packHeader(0x00, 0x01, "203.208.41.145", 443);
  console.assert(array_equals(testHeader, new Uint8Array([0x05, 0x00, 0x00, 0x01, 0xcb, 0xd0, 0x29, 0x91, 0x01, 0xbb])));
  testHeader = Common.packHeader(0x00, 0x03, "h.w", 80);
  console.assert(array_equals(testHeader, new Uint8Array([0x05, 0x00, 0x00, 0x03, 0x03, 0x68, 0x2e, 0x77, 0x00, 0x50])));
  testHeader = Common.packHeader(0x00, 0x04, "1234::5678", 8080);
  console.assert(array_equals(testHeader, new Uint8Array([0x05, 0x00, 0x00, 0x04, 0x12, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x78, 0x1f, 0x90])));
  testHeader = Common.packHeader(0x00, 0x80, "203.208.41.145", 443);
  console.assert(array_equals(testHeader, new Uint8Array([0x05, 0x00, 0x00, 0x01, 0xcb, 0xd0, 0x29, 0x91, 0x01, 0xbb])));
  testHeader = Common.packHeader(0x00, null, "h.w", 80);
  console.assert(array_equals(testHeader, new Uint8Array([0x05, 0x00, 0x00, 0x03, 0x03, 0x68, 0x2e, 0x77, 0x00, 0x50])));
  testHeader = Common.packHeader(0x00, null, "1234::5678", 8080);
  console.assert(array_equals(testHeader, new Uint8Array([0x05, 0x00, 0x00, 0x04, 0x12, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x78, 0x1f, 0x90])));
  return console.log("All test passed!");
};

// do Common.test
